<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Multi-Variante - Solucionador Mejorado</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #166088;
            --accent-color: #4cb5f5;
            --background-color: #f8f9fa;
            --card-color: #ffffff;
            --text-color: #333333;
            --border-color: #dddddd;
            --success-color: #28a745;
            --error-color: #dc3545;
            --warning-color: #ffc107;
            --hint-color: #ff9800;
        }

        .dark-theme {
            --primary-color: #5a7fb5;
            --secondary-color: #2660a8;
            --accent-color: #5cc5ff;
            --background-color: #1a1a1a;
            --card-color: #2d2d2d;
            --text-color: #f0f0f0;
            --border-color: #444444;
            --success-color: #38b753;
            --error-color: #e84545;
            --warning-color: #ffd54f;
            --hint-color: #ffa726;
        }

        .high-contrast-theme {
            --primary-color: #000000;
            --secondary-color: #ffffff;
            --accent-color: #ffff00;
            --background-color: #000000;
            --card-color: #111111;
            --text-color: #ffffff;
            --border-color: #ffffff;
            --success-color: #00ff00;
            --error-color: #ff0000;
            --warning-color: #ffff00;
            --hint-color: #ff7700;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem;
            text-align: center;
            border-radius: 15px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 2rem;
        }

        .sudoku-type {
            background-color: var(--card-color);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .sudoku-type:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
        }

        .sudoku-type h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .sudoku-type p {
            color: var(--text-color);
            opacity: 0.8;
            margin-bottom: 15px;
        }

        .sudoku-type .icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .game-container {
            display: none;
            background-color: var(--card-color);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .nav-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background-color: var(--secondary-color);
            color: white;
            cursor: pointer;
            font-weight: bold;
        }

        .nav-buttons button:hover {
            background-color: var(--primary-color);
        }

        .sudoku-grid {
            display: grid;
            margin: 0 auto;
            border: 2px solid var(--text-color);
            position: relative;
        }

        .sudoku-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1;
            border: 1px solid var(--border-color);
            font-size: 1.2rem;
            font-weight: bold;
            background-color: var(--card-color);
            cursor: pointer;
            position: relative;
        }

        .sudoku-cell.fixed {
            background-color: #e9ecef;
            color: var(--secondary-color);
            font-weight: bolder;
        }

        .sudoku-cell.selected {
            background-color: var(--accent-color);
            color: white;
        }

        .sudoku-cell.error {
            background-color: var(--error-color);
            color: white;
        }

        .sudoku-cell.hint {
            background-color: var(--hint-color);
            color: white;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .controls button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background-color: var(--secondary-color);
            color: white;
            cursor: pointer;
            font-weight: bold;
        }

        .controls button:hover {
            background-color: var(--primary-color);
        }

        .controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .number-selector {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin: 15px 0;
        }

        .number-btn {
            aspect-ratio: 1;
            border: 1px solid var(--border-color);
            background-color: var(--card-color);
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 4px;
        }

        .number-btn:hover {
            background-color: var(--accent-color);
            color: white;
        }

        .sidebar {
            background-color: var(--card-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .timer {
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stats {
            margin-bottom: 20px;
        }

        .stats h3 {
            margin-bottom: 10px;
            color: var(--secondary-color);
        }

        .stats p {
            margin: 5px 0;
        }

        .hint-section, .settings-section {
            margin-bottom: 20px;
        }

        .hint-section button, .settings-section button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 4px;
            background-color: var(--secondary-color);
            color: white;
            cursor: pointer;
        }

        .hint-section button:hover, .settings-section button:hover {
            background-color: var(--primary-color);
        }

        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: var(--text-color);
        }

        .theme-selector {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        /* Estilos para diferentes tama√±os de Sudoku */
        .sudoku-4x4 {
            grid-template-columns: repeat(4, 1fr);
            max-width: 300px;
        }

        .sudoku-6x6 {
            grid-template-columns: repeat(6, 1fr);
            max-width: 400px;
        }

        .sudoku-9x9 {
            grid-template-columns: repeat(9, 1fr);
            max-width: 500px;
        }

        .sudoku-21x21 {
            grid-template-columns: repeat(21, 1fr);
            max-width: 700px;
        }

        /* Estilos para regiones */
        .region-0 { background-color: rgba(255, 200, 200, 0.3); }
        .region-1 { background-color: rgba(200, 255, 200, 0.3); }
        .region-2 { background-color: rgba(200, 200, 255, 0.3); }
        .region-3 { background-color: rgba(255, 255, 200, 0.3); }
        .region-4 { background-color: rgba(255, 200, 255, 0.3); }
        .region-5 { background-color: rgba(200, 255, 255, 0.3); }

        /* Bordes m√°s gruesos para regiones */
        .border-right-thick {
            border-right: 3px solid var(--text-color) !important;
        }

        .border-bottom-thick {
            border-bottom: 3px solid var(--text-color) !important;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--card-color);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .close-modal {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            color: var(--secondary-color);
            background: none;
            border: none;
            z-index: 1001;
        }

        .close-modal:hover {
            color: var(--primary-color);
        }

        /* Monitor del Algoritmo Gen√©tico */
        #geneticMonitor {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-color);
            padding: 20px;
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            z-index: 10000;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        .close-monitor {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            color: var(--secondary-color);
            background: none;
            border: none;
            z-index: 1001;
        }

        .close-monitor:hover {
            color: var(--primary-color);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-menu {
                grid-template-columns: 1fr;
            }
            
            .sudoku-21x21 {
                grid-template-columns: repeat(9, 1fr);
                max-width: 350px;
            }
            
            header h1 {
                font-size: 2rem;
            }
            
            header p {
                font-size: 1rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }

            #geneticMonitor {
                width: 95%;
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .sudoku-9x9 {
                max-width: 350px;
            }
            
            .sudoku-6x6 {
                max-width: 300px;
            }
            
            .sudoku-4x4 {
                max-width: 250px;
            }
            
            .number-selector {
                grid-template-columns: repeat(3, 1fr);
            }

            #geneticMonitor {
                width: 98%;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="theme-selector">
            <select id="themeSelector">
                <option value="light">Tema Claro</option>
                <option value="dark">Tema Oscuro</option>
                <option value="high-contrast">Alto Contraste</option>
            </select>
        </div>

        <!-- P√ÅGINA PRINCIPAL -->
        <div id="mainPage">
            <header>
                <h1>üß© Sudoku Multi-Variante</h1>
                <p>Descubre el fascinante mundo de los Sudokus con m√∫ltiples variantes y desaf√≠os</p>
            </header>

            <div class="main-menu">
                <div class="sudoku-type" data-type="classic">
                    <div class="icon">9√ó9</div>
                    <h3>Sudoku Cl√°sico</h3>
                    <p>El tradicional Sudoku 9√ó9 con reglas est√°ndar. Perfecto para principiantes y expertos.</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>

                <div class="sudoku-type" data-type="killer">
                    <div class="icon">üî¢</div>
                    <h3>Killer Sudoku</h3>
                    <p>Adem√°s de las reglas normales, las celdas sombreadas deben sumar el valor indicado.</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>

                <div class="sudoku-type" data-type="samurai">
                    <div class="icon">üó°Ô∏è</div>
                    <h3>Samurai Sudoku</h3>
                    <p>Cinco sudokus interconectados que se resuelven simult√°neamente. ¬°El desaf√≠o definitivo!</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>

                <div class="sudoku-type" data-type="jigsaw">
                    <div class="icon">üß©</div>
                    <h3>Jigsaw Sudoku</h3>
                    <p>Las regiones tienen formas irregulares en lugar de los tradicionales cuadrados 3√ó3.</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>

                <div class="sudoku-type" data-type="x-sudoku">
                    <div class="icon">‚ùå</div>
                    <h3>X-Sudoku</h3>
                    <p>Las dos diagonales principales tambi√©n deben contener todos los d√≠gitos del 1 al 9.</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>

                <div class="sudoku-type" data-type="mini">
                    <div class="icon">4√ó4</div>
                    <h3>Mini Sudoku</h3>
                    <p>Perfecto para principiantes. Sudokus 4√ó4 y 6√ó6 para aprender las reglas b√°sicas.</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>
            </div>

            <footer>
                <p>Sudoku Multi-Variante &copy; 2024 - Desarrollado con ‚ù§Ô∏è para amantes del Sudoku</p>
            </footer>
        </div>

        <!-- P√ÅGINA DE JUEGO -->
        <div id="gamePage" class="game-container">
            <div class="nav-buttons">
                <button id="btnBack">‚Üê Volver al Men√∫</button>
                <button id="btnHelp">C√≥mo Jugar</button>
            </div>

            <header>
                <h1 id="gameTitle">Sudoku Cl√°sico</h1>
                <p id="gameDescription">Completa el tablero siguiendo las reglas tradicionales del Sudoku</p>
            </header>

            <div class="difficulty-selector">
                <h3>Selecciona Dificultad:</h3>
                <div class="controls">
                    <button class="difficulty-btn" data-difficulty="easy">F√°cil</button>
                    <button class="difficulty-btn" data-difficulty="medium">Medio</button>
                    <button class="difficulty-btn" data-difficulty="hard">Dif√≠cil</button>
                    <button class="difficulty-btn" data-difficulty="expert">Experto</button>
                </div>
            </div>

            <div class="main-content">
                <div class="game-area">
                    <div class="sudoku-container">
                        <div id="sudokuGrid" class="sudoku-grid sudoku-9x9">
                            <!-- Aqu√≠ se generar√° el tablero din√°micamente -->
                        </div>
                    </div>

                    <div class="controls">
                        <button id="btnCheck">Verificar</button>
                        <button id="btnSolve">Resolver con AG</button>
                        <button id="btnReset">Reiniciar</button>
                        <button id="btnUndo">Deshacer</button>
                        <button id="btnRedo">Rehacer</button>
                        <button id="btnNewGame">Nuevo Juego</button>
                        <button id="btnMonitorGA">Monitor GA</button>
                    </div>

                    <div class="number-selector">
                        <!-- Los botones num√©ricos se generar√°n din√°micamente -->
                    </div>
                </div>

                <div class="sidebar">
                    <div class="timer">
                        <span id="timer">00:00:00</span>
                    </div>

                    <div class="stats">
                        <h3>Estad√≠sticas</h3>
                        <p>Errores: <span id="errorCount">0</span></p>
                        <p>Pistas usadas: <span id="hintCount">0</span></p>
                        <p>Movimientos: <span id="moveCount">0</span></p>
                    </div>

                    <div class="hint-section">
                        <h3>Ayuda</h3>
                        <button id="btnHint">Obtener Pista</button>
                        <button id="btnExplain">Explicar T√©cnica</button>
                        <button id="btnCandidates">Mostrar Candidatos</button>
                    </div>

                    <div class="settings-section">
                        <h3>Opciones</h3>
                        <button id="btnSave">Guardar Partida</button>
                        <button id="btnLoad">Cargar Partida</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- MODAL DE AYUDA -->
        <div id="helpModal" class="modal">
            <div class="modal-content">
                <button class="close-modal">&times;</button>
                <h2 id="modalTitle">C√≥mo Jugar al Sudoku Cl√°sico</h2>
                <div id="modalContent">
                    <!-- El contenido se cargar√° din√°micamente seg√∫n el tipo de sudoku -->
                </div>
            </div>
        </div>

        <!-- MONITOR DEL ALGORITMO GEN√âTICO -->
        <div id="geneticMonitor">
            <button class="close-monitor">&times;</button>
            <h3>üß¨ Algoritmo Gen√©tico en Ejecuci√≥n</h3>
            <div style="text-align: center; margin: 15px 0;">
                <div id="gaProgress" style="height: 20px; background: #f0f0f0; border-radius: 10px; margin: 10px 0;">
                    <div id="gaProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--primary-color), var(--accent-color)); border-radius: 10px; transition: width 0.3s;"></div>
                </div>
                <div id="gaStats" style="font-size: 14px; margin: 10px 0;">
                    <div>Generaci√≥n: <span id="currentGeneration">0</span>/<span id="maxGenerations">5000</span></div>
                    <div>Mejor Fitness: <span id="bestFitness">0</span></div>
                    <div>Tiempo: <span id="gaTime">0</span>s</div>
                </div>
            </div>
            
            <div style="margin: 15px 0;">
                <h4>üìà Evoluci√≥n del Fitness</h4>
                <canvas id="gaChart" width="400" height="200" style="width: 100%; height: 200px; border: 1px solid #ddd;"></canvas>
            </div>
            
            <div style="margin: 15px 0;">
                <h4>üîç √öltima Operaci√≥n</h4>
                <div id="lastOperation" style="font-size: 12px; background: #f8f9fa; padding: 10px; border-radius: 5px;">
                    Preparando algoritmo gen√©tico...
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="stopGeneticAlgorithm()" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    Detener
                </button>
                <button onclick="togglePauseGA()" id="pauseBtn" style="padding: 8px 16px; background: #ffc107; color: black; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">
                    Pausar
                </button>
            </div>
        </div>
    </div>

    <script>
    // ==================== CLASE SudokuGenerator ====================
    class SudokuGenerator {
        constructor(size = 9) {
            this.size = size;
            this.grid = Array(size).fill().map(() => Array(size).fill(0));
            this.subgridSize = Math.sqrt(size);
        }

        generateComplete() {
            this.grid = Array(this.size).fill().map(() => Array(this.size).fill(0));
            this.solveComplete();
            return this.grid;
        }

        solveComplete() {
            for (let row = 0; row < this.size; row++) {
                for (let col = 0; col < this.size; col++) {
                    if (this.grid[row][col] === 0) {
                        const numbers = this.shuffleArray([...Array(this.size).keys()].map(n => n + 1));
                        
                        for (const num of numbers) {
                            if (this.isValidPlacement(row, col, num)) {
                                this.grid[row][col] = num;
                                
                                if (this.solveComplete()) {
                                    return true;
                                }
                                
                                this.grid[row][col] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }

        createPuzzle(difficulty) {
            const completeGrid = this.generateComplete();
            const puzzle = JSON.parse(JSON.stringify(completeGrid));
            
            const cellsToRemove = {
                'easy': 35,    // 46 pistas
                'medium': 45,  // 36 pistas  
                'hard': 52,    // 29 pistas
                'expert': 58   // 23 pistas
            }[difficulty] || 45;
            
            this.removeCells(puzzle, cellsToRemove);
            return puzzle;
        }

        removeCells(grid, count) {
            const cells = [];
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    cells.push({row: i, col: j});
                }
            }
            
            this.shuffleArray(cells);
            let removed = 0;
            
            for (const cell of cells) {
                if (removed >= count) break;
                
                const backup = grid[cell.row][cell.col];
                grid[cell.row][cell.col] = 0;
                
                if (this.hasUniqueSolution(JSON.parse(JSON.stringify(grid)))) {
                    removed++;
                } else {
                    grid[cell.row][cell.col] = backup;
                }
            }
        }

        hasUniqueSolution(grid) {
            const solutions = this.countSolutions(JSON.parse(JSON.stringify(grid)), 0);
            return solutions === 1;
        }

        countSolutions(grid, count) {
            if (count > 1) return count;
            
            for (let row = 0; row < this.size; row++) {
                for (let col = 0; col < this.size; col++) {
                    if (grid[row][col] === 0) {
                        for (let num = 1; num <= this.size; num++) {
                            if (this.isValidPlacementForGrid(grid, row, col, num)) {
                                grid[row][col] = num;
                                count = this.countSolutions(grid, count);
                                if (count > 1) return count;
                                grid[row][col] = 0;
                            }
                        }
                        return count;
                    }
                }
            }
            return count + 1;
        }

        isValidPlacementForGrid(grid, row, col, num) {
            for (let i = 0; i < this.size; i++) {
                if (grid[row][i] === num) return false;
            }
            
            for (let i = 0; i < this.size; i++) {
                if (grid[i][col] === num) return false;
            }
            
            const startRow = Math.floor(row / this.subgridSize) * this.subgridSize;
            const startCol = Math.floor(col / this.subgridSize) * this.subgridSize;
            
            for (let i = 0; i < this.subgridSize; i++) {
                for (let j = 0; j < this.subgridSize; j++) {
                    if (grid[startRow + i][startCol + j] === num) return false;
                }
            }
            
            return true;
        }

        isValidPlacement(row, col, num) {
            return this.isValidPlacementForGrid(this.grid, row, col, num);
        }

        shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
    }

    // ==================== CLASE SudokuKnowledgeBase ====================
    class SudokuKnowledgeBase {
        constructor() {
            this.techniques = {
                'single': {
                    name: '√önica Posibilidad',
                    description: 'Una celda solo puede contener un n√∫mero espec√≠fico porque es el √∫nico que falta en esa fila, columna o regi√≥n.'
                },
                'hidden-single': {
                    name: '√önica Ocultada',
                    description: 'Un n√∫mero solo puede ir en una celda espec√≠fica dentro de una fila, columna o regi√≥n, aunque haya otras posibilidades en esa celda.'
                },
                'locked-candidates': {
                    name: 'Candidatos Bloqueados',
                    description: 'Cuando un n√∫mero est√° confinado a una fila o columna dentro de una regi√≥n, puede eliminarse de otras celdas en esa fila o columna fuera de la regi√≥n.'
                }
            };
        }

        validateSolution(grid, gameType = 'classic', extraData = null) {
            const size = grid.length;
            
            // Validaci√≥n b√°sica para todos los tipos
            for (let i = 0; i < size; i++) {
                const rowSet = new Set();
                const colSet = new Set();
                
                for (let j = 0; j < size; j++) {
                    // Validar filas
                    if (grid[i][j] === 0 || rowSet.has(grid[i][j])) return false;
                    rowSet.add(grid[i][j]);
                    
                    // Validar columnas
                    if (grid[j][i] === 0 || colSet.has(grid[j][i])) return false;
                    colSet.add(grid[j][i]);
                }
            }
            
            // Validar regiones seg√∫n el tipo de sudoku
            if (gameType === 'classic' || gameType === 'x-sudoku' || gameType === 'mini') {
                const regionSize = Math.sqrt(size);
                for (let i = 0; i < size; i += regionSize) {
                    for (let j = 0; j < size; j += regionSize) {
                        const regionSet = new Set();
                        for (let x = i; x < i + regionSize; x++) {
                            for (let y = j; y < j + regionSize; y++) {
                                if (grid[x][y] === 0 || regionSet.has(grid[x][y])) return false;
                                regionSet.add(grid[x][y]);
                            }
                        }
                    }
                }
            }
            
            // Validaciones espec√≠ficas para cada tipo
            switch(gameType) {
                case 'x-sudoku':
                    // Validar diagonales principales
                    const diag1 = new Set();
                    const diag2 = new Set();
                    for (let i = 0; i < size; i++) {
                        if (grid[i][i] === 0 || diag1.has(grid[i][i])) return false;
                        diag1.add(grid[i][i]);
                        
                        if (grid[i][size-1-i] === 0 || diag2.has(grid[i][size-1-i])) return false;
                        diag2.add(grid[i][size-1-i]);
                    }
                    break;
                    
                case 'killer':
                    // Validar sumas de jaulas (si se proporcionan)
                    if (extraData && extraData.cages) {
                        for (const cage of extraData.cages) {
                            let sum = 0;
                            const seen = new Set();
                            for (const cell of cage.cells) {
                                const value = grid[cell.row][cell.col];
                                if (value === 0) return false;
                                if (seen.has(value)) return false;
                                seen.add(value);
                                sum += value;
                            }
                            if (sum !== cage.sum) return false;
                        }
                    }
                    break;
                    
                // Aqu√≠ se pueden agregar validaciones para otros tipos de sudoku
            }
            
            return true;
        }

        getHint(grid, gameType = 'classic') {
            // Implementaci√≥n simplificada - en una aplicaci√≥n real, esto ser√≠a m√°s complejo
            const emptyCells = [];
            for (let i = 0; i < grid.length; i++) {
                for (let j = 0; j < grid[i].length; j++) {
                    if (grid[i][j] === 0) {
                        emptyCells.push({row: i, col: j});
                    }
                }
            }
            
            if (emptyCells.length === 0) return null;
            
            // Seleccionar una celda aleatoria vac√≠a
            const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            
            // Encontrar un n√∫mero v√°lido para esa celda
            for (let num = 1; num <= grid.length; num++) {
                if (this.isValidPlacement(grid, randomCell.row, randomCell.col, num, gameType)) {
                    return {
                        row: randomCell.row,
                        col: randomCell.col,
                        value: num,
                        technique: Object.keys(this.techniques)[Math.floor(Math.random() * Object.keys(this.techniques).length)]
                    };
                }
            }
            
            return null;
        }

        isValidPlacement(grid, row, col, num, gameType = 'classic') {
            const size = grid.length;
            
            // Verificar fila
            for (let i = 0; i < size; i++) {
                if (grid[row][i] === num) return false;
            }
            
            // Verificar columna
            for (let i = 0; i < size; i++) {
                if (grid[i][col] === num) return false;
            }
            
            // Verificar regi√≥n
            const regionSize = Math.sqrt(size);
            const startRow = Math.floor(row / regionSize) * regionSize;
            const startCol = Math.floor(col / regionSize) * regionSize;
            
            for (let i = startRow; i < startRow + regionSize; i++) {
                for (let j = startCol; j < startCol + regionSize; j++) {
                    if (grid[i][j] === num) return false;
                }
            }
            
            return true;
        }

        getTechniqueExplanation(techniqueKey) {
            return this.techniques[techniqueKey] || {
                name: 'T√©cnica no disponible',
                description: 'No hay explicaci√≥n disponible para esta t√©cnica.'
            };
        }
    }

    // ==================== CLASE SudokuGeneticSolver ====================
    class SudokuGeneticSolver {
        constructor(grid, size = 9) {
            this.grid = grid;
            this.size = size;
            this.populationSize = 500;
            this.mutationRate = 0.15;
            this.maxGenerations = 5000;
            this.population = [];
            this.bestSolution = null;
            this.bestFitness = -Infinity;
            this.onGeneration = null;
            this.isPaused = false;
            this.shouldStop = false;
            this.generationCount = 0;
            this.emptyCells = this.findEmptyCells();
        }

        findEmptyCells() {
            const empty = [];
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (this.grid[i][j] === 0) {
                        empty.push({ row: i, col: j });
                    }
                }
            }
            return empty;
        }

        initializePopulation() {
            this.population = [];
            for (let i = 0; i < this.populationSize; i++) {
                const individual = this.createValidIndividual();
                this.population.push(individual);
            }
        }

        createValidIndividual() {
            const individual = JSON.parse(JSON.stringify(this.grid));
            
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (individual[i][j] === 0) {
                        individual[i][j] = Math.floor(Math.random() * this.size) + 1;
                    }
                }
            }
            
            return individual;
        }

        calculateFitness(individual) {
            let fitness = 0;
            
            // Evaluar filas
            for (let i = 0; i < this.size; i++) {
                const rowSet = new Set(individual[i]);
                fitness += rowSet.size;
            }
            
            // Evaluar columnas
            for (let j = 0; j < this.size; j++) {
                const colSet = new Set();
                for (let i = 0; i < this.size; i++) {
                    colSet.add(individual[i][j]);
                }
                fitness += colSet.size;
            }
            
            // Evaluar regiones
            const regionSize = Math.sqrt(this.size);
            for (let i = 0; i < this.size; i += regionSize) {
                for (let j = 0; j < this.size; j += regionSize) {
                    const regionSet = new Set();
                    for (let x = i; x < i + regionSize; x++) {
                        for (let y = j; y < j + regionSize; y++) {
                            regionSet.add(individual[x][y]);
                        }
                    }
                    fitness += regionSet.size;
                }
            }
            
            return fitness;
        }

        selectParent() {
            const tournamentSize = 5;
            let best = null;
            let bestFitness = -Infinity;
            
            for (let i = 0; i < tournamentSize; i++) {
                const candidate = this.population[Math.floor(Math.random() * this.population.length)];
                const fitness = this.calculateFitness(candidate);
                
                if (fitness > bestFitness) {
                    best = candidate;
                    bestFitness = fitness;
                }
            }
            
            return best;
        }

        crossover(parent1, parent2) {
            const child = JSON.parse(JSON.stringify(this.grid));
            const crossoverPoint = Math.floor(Math.random() * this.emptyCells.length);
            
            for (let i = 0; i < this.emptyCells.length; i++) {
                const { row, col } = this.emptyCells[i];
                child[row][col] = i < crossoverPoint ? parent1[row][col] : parent2[row][col];
            }
            
            return child;
        }

        mutate(individual) {
            for (const { row, col } of this.emptyCells) {
                if (Math.random() < this.mutationRate) {
                    individual[row][col] = Math.floor(Math.random() * this.size) + 1;
                }
            }
            return individual;
        }

        async solve(onGenerationCallback = null) {
            this.onGeneration = onGenerationCallback;
            this.initializePopulation();
            this.bestSolution = null;
            this.bestFitness = -Infinity;
            this.generationCount = 0;
            this.shouldStop = false;
            
            const startTime = performance.now();
            
            for (this.generationCount = 0; this.generationCount < this.maxGenerations; this.generationCount++) {
                if (this.shouldStop) break;
                
                while (this.isPaused) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    if (this.shouldStop) break;
                }
                
                // Evaluar poblaci√≥n
                let bestInGen = null;
                let bestInGenFitness = -Infinity;
                
                for (const individual of this.population) {
                    const fitness = this.calculateFitness(individual);
                    
                    if (fitness > bestInGenFitness) {
                        bestInGen = individual;
                        bestInGenFitness = fitness;
                    }
                    
                    if (fitness > this.bestFitness) {
                        this.bestSolution = individual;
                        this.bestFitness = fitness;
                    }
                }
                
                // Verificar si encontramos una soluci√≥n perfecta
                if (this.bestFitness === this.size * 3 * this.size) {
                    break;
                }
                
                // Crear nueva poblaci√≥n
                const newPopulation = [this.bestSolution]; // Elitismo
                
                while (newPopulation.length < this.populationSize) {
                    const parent1 = this.selectParent();
                    const parent2 = this.selectParent();
                    let child = this.crossover(parent1, parent2);
                    child = this.mutate(child);
                    newPopulation.push(child);
                }
                
                this.population = newPopulation;
                
                // Llamar al callback de actualizaci√≥n
                if (this.onGeneration) {
                    this.onGeneration({
                        generation: this.generationCount,
                        bestFitness: this.bestFitness,
                        maxFitness: this.size * 3 * this.size,
                        timeElapsed: (performance.now() - startTime) / 1000
                    });
                }
                
                // Peque√±a pausa para no bloquear la interfaz
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            
            return this.bestSolution;
        }

        pause() {
            this.isPaused = true;
        }

        resume() {
            this.isPaused = false;
        }

        stop() {
            this.shouldStop = true;
        }
    }

    // ==================== APLICACI√ìN PRINCIPAL ====================
    document.addEventListener('DOMContentLoaded', function() {
        // Variables globales de la aplicaci√≥n
        let currentGameType = 'classic';
        let currentDifficulty = 'medium';
        let gameGrid = [];
        let solutionGrid = [];
        let selectedCell = null;
        let gameHistory = [];
        let historyPointer = -1;
        let timerInterval = null;
        let startTime = null;
        let errorCount = 0;
        let hintCount = 0;
        let moveCount = 0;
        let gameCompleted = false;
        let geneticSolver = null;
        let fitnessHistory = [];
        
        // Elementos DOM
        const mainPage = document.getElementById('mainPage');
        const gamePage = document.getElementById('gamePage');
        const sudokuGrid = document.getElementById('sudokuGrid');
        const timerElement = document.getElementById('timer');
        const errorCountElement = document.getElementById('errorCount');
        const hintCountElement = document.getElementById('hintCount');
        const moveCountElement = document.getElementById('moveCount');
        const gameTitleElement = document.getElementById('gameTitle');
        const gameDescriptionElement = document.getElementById('gameDescription');
        const helpModal = document.getElementById('helpModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalContent = document.getElementById('modalContent');
        const themeSelector = document.getElementById('themeSelector');
        const geneticMonitor = document.getElementById('geneticMonitor');
        
        // Inicializar base de conocimientos
        const knowledgeBase = new SudokuKnowledgeBase();
        
        // Inicializar eventos
        initializeEvents();
        
        function initializeEvents() {
            // Botones de tipo de sudoku
            document.querySelectorAll('.sudoku-type .play-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const type = this.parentElement.getAttribute('data-type');
                    startNewGame(type);
                });
            });
            
            // Botones de navegaci√≥n
            document.getElementById('btnBack').addEventListener('click', function() {
                showMainPage();
            });
            
            document.getElementById('btnHelp').addEventListener('click', function() {
                showHelpModal(currentGameType);
            });
            
            // Botones de control del juego
            document.getElementById('btnCheck').addEventListener('click', checkSolution);
            document.getElementById('btnSolve').addEventListener('click', solveWithGeneticAlgorithm);
            document.getElementById('btnReset').addEventListener('click', resetGame);
            document.getElementById('btnUndo').addEventListener('click', undoMove);
            document.getElementById('btnRedo').addEventListener('click', redoMove);
            document.getElementById('btnNewGame').addEventListener('click', function() {
                startNewGame(currentGameType);
            });
            document.getElementById('btnHint').addEventListener('click', provideHint);
            document.getElementById('btnExplain').addEventListener('click', explainTechnique);
            document.getElementById('btnCandidates').addEventListener('click', toggleCandidates);
            document.getElementById('btnSave').addEventListener('click', saveGame);
            document.getElementById('btnLoad').addEventListener('click', loadGame);
            document.getElementById('btnMonitorGA').addEventListener('click', showGeneticMonitor);
            
            // Botones de dificultad
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    currentDifficulty = this.getAttribute('data-difficulty');
                    startNewGame(currentGameType);
                });
            });
            
            // Selector de tema
            themeSelector.addEventListener('change', function() {
                changeTheme(this.value);
            });
            
            // Cerrar modales
            document.querySelectorAll('.close-modal, .close-monitor').forEach(btn => {
                btn.addEventListener('click', function() {
                    this.closest('.modal, #geneticMonitor').style.display = 'none';
                });
            });
            
            // Cerrar modal al hacer clic fuera
            window.addEventListener('click', function(event) {
                if (event.target === helpModal) {
                    helpModal.style.display = 'none';
                }
                if (event.target === geneticMonitor) {
                    geneticMonitor.style.display = 'none';
                }
            });
        }
        
        function startNewGame(type) {
            currentGameType = type;
            gameCompleted = false;
            errorCount = 0;
            hintCount = 0;
            moveCount = 0;
            gameHistory = [];
            historyPointer = -1;
            
            updateGameTitle(type);
            
            // Generar nuevo tablero seg√∫n el tipo
            let gridSize = 9;
            if (type === 'mini') gridSize = Math.random() > 0.5 ? 4 : 6;
            
            const generator = new SudokuGenerator(gridSize);
            gameGrid = generator.createPuzzle(currentDifficulty);
            solutionGrid = JSON.parse(JSON.stringify(gameGrid));
            
            // Guardar estado inicial
            saveGameState();
            
            // Renderizar tablero
            renderSudokuGrid();
            
            // Iniciar temporizador
            startTimer();
            
            // Mostrar p√°gina de juego
            showGamePage();
        }
        
        function updateGameTitle(type) {
            const titles = {
                'classic': 'Sudoku Cl√°sico',
                'killer': 'Killer Sudoku',
                'samurai': 'Samurai Sudoku',
                'jigsaw': 'Jigsaw Sudoku',
                'x-sudoku': 'X-Sudoku',
                'mini': 'Mini Sudoku'
            };
            
            const descriptions = {
                'classic': 'Completa el tablero siguiendo las reglas tradicionales del Sudoku',
                'killer': 'Completa el tablero respetando las sumas de las jaulas',
                'samurai': 'Resuelve cinco sudokus interconectados simult√°neamente',
                'jigsaw': 'Las regiones tienen formas irregulares en lugar de cuadrados',
                'x-sudoku': 'Las diagonales principales tambi√©n deben contener todos los d√≠gitos',
                'mini': 'Sudoku en formato reducido para principiantes'
            };
            
            gameTitleElement.textContent = titles[type] || 'Sudoku';
            gameDescriptionElement.textContent = descriptions[type] || 'Completa el tablero siguiendo las reglas del Sudoku';
        }
        
        function renderSudokuGrid() {
            sudokuGrid.innerHTML = '';
            const size = gameGrid.length;
            
            // Establecer clase de tama√±o
            sudokuGrid.className = 'sudoku-grid';
            if (size === 4) sudokuGrid.classList.add('sudoku-4x4');
            else if (size === 6) sudokuGrid.classList.add('sudoku-6x6');
            else if (size === 9) sudokuGrid.classList.add('sudoku-9x9');
            else if (size === 21) sudokuGrid.classList.add('sudoku-21x21');
            
            // Crear celdas
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'sudoku-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    // Aplicar clases seg√∫n el tipo de juego
                    if (gameGrid[i][j] !== 0) {
                        cell.textContent = gameGrid[i][j];
                        cell.classList.add('fixed');
                    }
                    
                    // Aplicar bordes gruesos para regiones
                    if ((j + 1) % Math.sqrt(size) === 0 && j !== size - 1) {
                        cell.classList.add('border-right-thick');
                    }
                    
                    if ((i + 1) % Math.sqrt(size) === 0 && i !== size - 1) {
                        cell.classList.add('border-bottom-thick');
                    }
                    
                    // Aplicar estilos espec√≠ficos seg√∫n el tipo de juego
                    if (currentGameType === 'x-sudoku' && (i === j || i === size - 1 - j)) {
                        cell.classList.add('x-diagonal');
                    }
                    
                    cell.addEventListener('click', function() {
                        selectCell(i, j);
                    });
                    
                    sudokuGrid.appendChild(cell);
                }
            }
            
            // Renderizar selectores de n√∫meros
            renderNumberSelector();
        }
        
        function renderNumberSelector() {
            const selector = document.querySelector('.number-selector');
            selector.innerHTML = '';
            
            const size = gameGrid.length;
            
            for (let i = 1; i <= size; i++) {
                const btn = document.createElement('button');
                btn.className = 'number-btn';
                btn.textContent = i;
                btn.addEventListener('click', function() {
                    if (selectedCell) {
                        setCellValue(selectedCell.row, selectedCell.col, i);
                    }
                });
                selector.appendChild(btn);
            }
            
            // Bot√≥n para borrar
            const clearBtn = document.createElement('button');
            clearBtn.className = 'number-btn';
            clearBtn.textContent = 'X';
            clearBtn.addEventListener('click', function() {
                if (selectedCell) {
                    setCellValue(selectedCell.row, selectedCell.col, 0);
                }
            });
            selector.appendChild(clearBtn);
        }
        
        function selectCell(row, col) {
            // Deseleccionar celda anterior
            if (selectedCell) {
                const prevCell = document.querySelector(`.sudoku-cell[data-row="${selectedCell.row}"][data-col="${selectedCell.col}"]`);
                if (prevCell) prevCell.classList.remove('selected');
            }
            
            // Seleccionar nueva celda
            selectedCell = { row, col };
            const cell = document.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${col}"]`);
            if (cell && !cell.classList.contains('fixed')) {
                cell.classList.add('selected');
            }
        }
        
        function setCellValue(row, col, value) {
            // Solo permitir modificar celdas no fijas
            if (gameGrid[row][col] !== 0 && gameGrid[row][col] === solutionGrid[row][col]) {
                return;
            }
            
            // Guardar estado actual en el historial
            saveGameState();
            
            // Actualizar valor
            gameGrid[row][col] = value;
            
            // Actualizar interfaz
            const cell = document.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${col}"]`);
            if (cell) {
                cell.textContent = value === 0 ? '' : value;
                
                // Validar si el valor es correcto
                if (value !== 0) {
                    if (value === solutionGrid[row][col]) {
                        cell.classList.remove('error');
                    } else {
                        cell.classList.add('error');
                        errorCount++;
                        errorCountElement.textContent = errorCount;
                    }
                } else {
                    cell.classList.remove('error');
                }
            }
            
            moveCount++;
            moveCountElement.textContent = moveCount;
            
            // Verificar si el juego est√° completo
            checkCompletion();
        }
        
        function saveGameState() {
            // Eliminar estados futuros si estamos en medio del historial
            if (historyPointer < gameHistory.length - 1) {
                gameHistory = gameHistory.slice(0, historyPointer + 1);
            }
            
            // Guardar estado actual
            gameHistory.push(JSON.parse(JSON.stringify(gameGrid)));
            historyPointer = gameHistory.length - 1;
            
            // Actualizar botones de deshacer/rehacer
            updateUndoRedoButtons();
        }
        
        function undoMove() {
            if (historyPointer > 0) {
                historyPointer--;
                gameGrid = JSON.parse(JSON.stringify(gameHistory[historyPointer]));
                renderSudokuGrid();
                if (selectedCell) {
                    selectCell(selectedCell.row, selectedCell.col);
                }
                updateUndoRedoButtons();
            }
        }
        
        function redoMove() {
            if (historyPointer < gameHistory.length - 1) {
                historyPointer++;
                gameGrid = JSON.parse(JSON.stringify(gameHistory[historyPointer]));
                renderSudokuGrid();
                if (selectedCell) {
                    selectCell(selectedCell.row, selectedCell.col);
                }
                updateUndoRedoButtons();
            }
        }
        
        function updateUndoRedoButtons() {
            document.getElementById('btnUndo').disabled = historyPointer <= 0;
            document.getElementById('btnRedo').disabled = historyPointer >= gameHistory.length - 1;
        }
        
        function checkSolution() {
            const isValid = knowledgeBase.validateSolution(gameGrid, currentGameType);
            
            if (isValid) {
                alert('¬°Felicidades! El sudoku est√° resuelto correctamente.');
                gameCompleted = true;
                stopTimer();
            } else {
                alert('El sudoku contiene errores. Por favor, revisa tu soluci√≥n.');
            }
        }
        
        function checkCompletion() {
            // Verificar si todas las celdas est√°n llenas
            for (let i = 0; i < gameGrid.length; i++) {
                for (let j = 0; j < gameGrid[i].length; j++) {
                    if (gameGrid[i][j] === 0) return;
                }
            }
            
            // Verificar si la soluci√≥n es correcta
            const isValid = knowledgeBase.validateSolution(gameGrid, currentGameType);
            
            if (isValid) {
                alert('¬°Felicidades! Has completado el sudoku correctamente.');
                gameCompleted = true;
                stopTimer();
            }
        }
        
        function provideHint() {
            const hint = knowledgeBase.getHint(gameGrid, currentGameType);
            
            if (hint) {
                // Destacar la celda con la pista
                const cell = document.querySelector(`.sudoku-cell[data-row="${hint.row}"][data-col="${hint.col}"]`);
                if (cell) {
                    cell.classList.add('hint');
                    setTimeout(() => {
                        cell.classList.remove('hint');
                    }, 2000);
                }
                
                setCellValue(hint.row, hint.col, hint.value);
                hintCount++;
                hintCountElement.textContent = hintCount;
                
                // Mostrar explicaci√≥n de la t√©cnica utilizada
                const technique = knowledgeBase.getTechniqueExplanation(hint.technique);
                alert(`Pista: Coloca ${hint.value} en la fila ${hint.row + 1}, columna ${hint.col + 1}\n\nT√©cnica: ${technique.name}\nDescripci√≥n: ${technique.description}`);
            } else {
                alert('No se pudo generar una pista. ¬øEst√° el sudoku completo?');
            }
        }
        
        function explainTechnique() {
            const techniques = Object.keys(knowledgeBase.techniques);
            const randomTechnique = techniques[Math.floor(Math.random() * techniques.length)];
            const technique = knowledgeBase.getTechniqueExplanation(randomTechnique);
            
            alert(`T√©cnica: ${technique.name}\n\nDescripci√≥n: ${technique.description}`);
        }
        
        function toggleCandidates() {
            alert('Funci√≥n de candidatos activada. Los n√∫meros posibles se mostrar√°n en las celdas vac√≠as.');
            // En una implementaci√≥n completa, esto mostrar√≠a/ocultar√≠a los n√∫meros candidatos
        }
        
        function solveWithGeneticAlgorithm() {
            if (geneticSolver && !geneticSolver.shouldStop) {
                alert('El algoritmo gen√©tico ya est√° en ejecuci√≥n.');
                return;
            }
            
            showGeneticMonitor();
            
            geneticSolver = new SudokuGeneticSolver(gameGrid, gameGrid.length);
            fitnessHistory = [];
            
            geneticSolver.solve(function(stats) {
                // Actualizar monitor
                document.getElementById('currentGeneration').textContent = stats.generation;
                document.getElementById('bestFitness').textContent = stats.bestFitness;
                document.getElementById('maxGenerations').textContent = geneticSolver.maxGenerations;
                document.getElementById('gaTime').textContent = stats.timeElapsed.toFixed(2);
                
                // Actualizar barra de progreso
                const progressPercent = (stats.generation / geneticSolver.maxGenerations) * 100;
                document.getElementById('gaProgressBar').style.width = `${progressPercent}%`;
                
                // Guardar datos para la gr√°fica
                fitnessHistory.push({
                    generation: stats.generation,
                    fitness: stats.bestFitness
                });
                
                // Actualizar √∫ltima operaci√≥n
                document.getElementById('lastOperation').textContent = 
                    `Generaci√≥n ${stats.generation}: Fitness = ${stats.bestFitness}`;
                
                // Si encontramos una soluci√≥n perfecta, actualizar el tablero
                if (stats.bestFitness === stats.maxFitness) {
                    gameGrid = geneticSolver.bestSolution;
                    renderSudokuGrid();
                    alert('¬°Sudoku resuelto con √©xito usando el algoritmo gen√©tico!');
                    geneticMonitor.style.display = 'none';
                }
            }).then(solution => {
                if (solution && geneticSolver.bestFitness !== gameGrid.length * 3 * gameGrid.length) {
                    // Mostrar la mejor soluci√≥n encontrada aunque no sea perfecta
                    gameGrid = geneticSolver.bestSolution;
                    renderSudokuGrid();
                    alert(`El algoritmo gen√©tico termin√≥ con un fitness de ${geneticSolver.bestFitness}. La soluci√≥n podr√≠a no ser perfecta.`);
                }
            });
        }
        
        function showGeneticMonitor() {
            geneticMonitor.style.display = 'block';
        }
        
        function stopGeneticAlgorithm() {
            if (geneticSolver) {
                geneticSolver.stop();
                geneticMonitor.style.display = 'none';
            }
        }
        
        function togglePauseGA() {
            if (geneticSolver) {
                if (geneticSolver.isPaused) {
                    geneticSolver.resume();
                    document.getElementById('pauseBtn').textContent = 'Pausar';
                } else {
                    geneticSolver.pause();
                    document.getElementById('pauseBtn').textContent = 'Reanudar';
                }
            }
        }
        
        function resetGame() {
            if (confirm('¬øEst√°s seguro de que quieres reiniciar el juego? Se perder√° todo tu progreso.')) {
                gameGrid = JSON.parse(JSON.stringify(solutionGrid));
                renderSudokuGrid();
                gameHistory = [];
                historyPointer = -1;
                errorCount = 0;
                hintCount = 0;
                moveCount = 0;
                errorCountElement.textContent = errorCount;
                hintCountElement.textContent = hintCount;
                moveCountElement.textContent = moveCount;
                stopTimer();
                startTimer();
            }
        }
        
        function saveGame() {
            const gameData = {
                type: currentGameType,
                difficulty: currentDifficulty,
                grid: gameGrid,
                solution: solutionGrid,
                time: timerElement.textContent,
                errors: errorCount,
                hints: hintCount,
                moves: moveCount,
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('sudokuSavedGame', JSON.stringify(gameData));
            alert('Juego guardado correctamente.');
        }
        
        function loadGame() {
            const savedData = localStorage.getItem('sudokuSavedGame');
            
            if (savedData) {
                const gameData = JSON.parse(savedData);
                
                currentGameType = gameData.type;
                currentDifficulty = gameData.difficulty;
                gameGrid = gameData.grid;
                solutionGrid = gameData.solution;
                errorCount = gameData.errors;
                hintCount = gameData.hints;
                moveCount = gameData.moves;
                
                updateGameTitle(currentGameType);
                renderSudokuGrid();
                
                errorCountElement.textContent = errorCount;
                hintCountElement.textContent = hintCount;
                moveCountElement.textContent = moveCount;
                timerElement.textContent = gameData.time;
                
                showGamePage();
                alert('Juego cargado correctamente.');
            } else {
                alert('No hay ning√∫n juego guardado.');
            }
        }
        
        function startTimer() {
            stopTimer();
            startTime = new Date();
            
            timerInterval = setInterval(function() {
                const now = new Date();
                const diff = now - startTime;
                
                const hours = Math.floor(diff / 3600000);
                const minutes = Math.floor((diff % 3600000) / 60000);
                const seconds = Math.floor((diff % 60000) / 1000);
                
                timerElement.textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }
        
        function showMainPage() {
            gamePage.style.display = 'none';
            mainPage.style.display = 'block';
            stopTimer();
            
            if (geneticSolver) {
                geneticSolver.stop();
            }
        }
        
        function showGamePage() {
            mainPage.style.display = 'none';
            gamePage.style.display = 'block';
        }
        
        function showHelpModal(type) {
            const helpContents = {
                'classic': `
                    <h3>Reglas del Sudoku Cl√°sico</h3>
                    <p>El objetivo del Sudoku es rellenar una cuadr√≠cula de 9√ó9 con d√≠gitos de tal forma que cada columna, cada fila y cada una de las nueve subcuadr√≠culas 3√ó3 que componen la cuadr√≠cula contengan todos los d√≠gitos del 1 al 9.</p>
                    <h3>Consejos para resolver</h3>
                    <ul>
                        <li>Comienza por los n√∫meros que ya est√°n presentes y busca d√≥nde pueden ir los mismos n√∫meros en otras partes del tablero.</li>
                        <li>Busca filas, columnas o regiones que tengan muchos n√∫meros ya colocados.</li>
                        <li>Usa el proceso de eliminaci√≥n para determinar qu√© n√∫meros pueden ir en cada celda.</li>
                    </ul>
                `,
                'killer': `
                    <h3>Reglas del Killer Sudoku</h3>
                    <p>Adem√°s de las reglas normales del Sudoku, el Killer Sudoku tiene "jaulas" (√°reas delimitadas) con una suma indicada. Los n√∫meros dentro de cada jaula deben sumar exactamente el valor indicado, y no pueden repetirse dentro de una misma jaula.</p>
                    <h3>Consejos para resolver</h3>
                    <ul>
                        <li>Identifica las jaulas con sumas bajas o altas, ya que tienen combinaciones limitadas de n√∫meros.</li>
                        <li>Recuerda que los n√∫meros no pueden repetirse dentro de una jaula, incluso si las reglas normales del Sudoku lo permitir√≠an.</li>
                        <li>Combina las restricciones de suma con las reglas tradicionales del Sudoku.</li>
                    </ul>
                `,
                'samurai': `
                    <h3>Reglas del Samurai Sudoku</h3>
                    <p>El Samurai Sudoku consiste en cinco cuadr√≠culas de Sudoku 9√ó9 interconectadas. La cuadr√≠cula central comparte sus cuatro esquinas con las otras cuatro cuadr√≠culas. Debes resolver las cinco cuadr√≠culas simult√°neamente, aplicando las reglas est√°ndar a cada una.</p>
                    <h3>Consejos para resolver</h3>
                    <ul>
                        <li>Comienza por la cuadr√≠cula central, ya que afecta a todas las dem√°s.</li>
                        <li>Presta especial atenci√≥n a las regiones superpuestas, ya que deben cumplir las reglas de dos cuadr√≠culas simult√°neamente.</li>
                        <li>Trata de resolver progresivamente, pasando de una cuadr√≠cula a otra seg√∫n vayas obteniendo informaci√≥n.</li>
                    </ul>
                `,
                'jigsaw': `
                    <h3>Reglas del Jigsaw Sudoku</h3>
                    <p>El Jigsaw Sudoku sigue las mismas reglas b√°sicas que el Sudoku tradicional, pero las regiones (que normalmente son cuadrados 3√ó3) tienen formas irregulares. Cada fila, columna y regi√≥n de forma irregular debe contener los d√≠gitos del 1 al 9 sin repeticiones.</p>
                    <h3>Consejos para resolver</h3>
                    <ul>
                        <li>Identifica la forma de cada regi√≥n irregular para entender las restricciones.</li>
                        <li>Presta atenci√≥n a c√≥mo las regiones irregulares interact√∫an con filas y columnas.</li>
                        <li>Las t√©cnicas tradicionales de Sudoku siguen siendo aplicables, pero adaptadas a las formas irregulares.</li>
                    </ul>
                `,
                'x-sudoku': `
                    <h3>Reglas del X-Sudoku</h3>
                    <p>El X-Sudoku a√±ade una regla adicional al Sudoku tradicional: las dos diagonales principales tambi√©n deben contener cada una todos los d√≠gitos del 1 al 9 sin repeticiones. Esto a√±ade restricciones adicionales que hacen el juego m√°s desafiante.</p>
                    <h3>Consejos para resolver</h3>
                    <ul>
                        <li>Presta atenci√≥n a las diagonales desde el principio, ya que limitan las posibilidades en muchas celdas.</li>
                        <li>Las celdas donde se cruzan una diagonal con una fila o columna son particularmente restrictivas.</li>
                        <li>Usa la informaci√≥n de las diagonales para eliminar candidatos en filas y columnas.</li>
                    </ul>
                `,
                'mini': `
                    <h3>Reglas del Mini Sudoku</h3>
                    <p>El Mini Sudoku es una versi√≥n reducida del Sudoku tradicional, con cuadr√≠culas de 4√ó4 o 6√ó6. Las reglas son las mismas: cada fila, columna y regi√≥n debe contener todos los n√∫meros posibles (1-4 para 4√ó4, 1-6 para 6√ó6) sin repeticiones.</p>
                    <h3>Consejos para resolver</h3>
                    <ul>
                        <li>Ideal para principiantes que quieren aprender las reglas del Sudoku.</li>
                        <li>Aunque m√°s peque√±o, requiere la misma l√≥gica que los Sudokus m√°s grandes.</li>
                        <li>Es una buena manera de practicar t√©cnicas b√°sicas antes de abordar Sudokus 9√ó9.</li>
                    </ul>
                `
            };
            
            modalTitle.textContent = `C√≥mo jugar al ${document.getElementById('gameTitle').textContent}`;
            modalContent.innerHTML = helpContents[type] || helpContents['classic'];
            helpModal.style.display = 'flex';
        }
        
        function changeTheme(theme) {
            document.body.classList.remove('dark-theme', 'high-contrast-theme');
            
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
            } else if (theme === 'high-contrast') {
                document.body.classList.add('high-contrast-theme');
            }
            
            localStorage.setItem('sudokuTheme', theme);
        }
        
        // Cargar tema guardado
        const savedTheme = localStorage.getItem('sudokuTheme') || 'light';
        themeSelector.value = savedTheme;
        changeTheme(savedTheme);
    });
    </script>
</body>
</html>