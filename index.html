<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Multi-Variante con Algoritmo Gen√©tico</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #166088;
            --accent-color: #4cb5f5;
            --background-color: #f8f9fa;
            --card-color: #ffffff;
            --text-color: #333333;
            --border-color: #dddddd;
            --success-color: #28a745;
            --error-color: #dc3545;
            --warning-color: #ffc107;
        }

        .dark-theme {
            --primary-color: #5a7fb5;
            --secondary-color: #2660a8;
            --accent-color: #5cc5ff;
            --background-color: #1a1a1a;
            --card-color: #2d2d2d;
            --text-color: #f0f0f0;
            --border-color: #444444;
        }

        .high-contrast-theme {
            --primary-color: #000000;
            --secondary-color: #ffffff;
            --accent-color: #ffff00;
            --background-color: #000000;
            --card-color: #111111;
            --text-color: #ffffff;
            --border-color: #ffffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem;
            text-align: center;
            border-radius: 15px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 2rem;
        }

        .sudoku-type {
            background-color: var(--card-color);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .sudoku-type:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
        }

        .sudoku-type h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .sudoku-type p {
            color: var(--text-color);
            opacity: 0.8;
            margin-bottom: 15px;
        }

        .sudoku-type .icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .game-container {
            display: none;
            background-color: var(--card-color);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .nav-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background-color: var(--secondary-color);
            color: white;
            cursor: pointer;
            font-weight: bold;
        }

        .nav-buttons button:hover {
            background-color: var(--primary-color);
        }

        .sudoku-grid {
            display: grid;
            margin: 0 auto;
            border: 2px solid var(--text-color);
            position: relative;
        }

        .sudoku-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1;
            border: 1px solid var(--border-color);
            font-size: 1.2rem;
            font-weight: bold;
            background-color: var(--card-color);
            cursor: pointer;
            position: relative;
        }

        .sudoku-cell.fixed {
            background-color: #e9ecef;
            color: var(--secondary-color);
            font-weight: bolder;
        }

        .sudoku-cell.selected {
            background-color: var(--accent-color);
            color: white;
        }

        .sudoku-cell.error {
            background-color: #ffebee;
            color: var(--error-color);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .controls button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background-color: var(--secondary-color);
            color: white;
            cursor: pointer;
            font-weight: bold;
        }

        .controls button:hover {
            background-color: var(--primary-color);
        }

        .controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .number-selector {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin: 15px 0;
        }

        .number-btn {
            aspect-ratio: 1;
            border: 1px solid var(--border-color);
            background-color: var(--card-color);
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 4px;
        }

        .number-btn:hover {
            background-color: var(--accent-color);
            color: white;
        }

        .sidebar {
            background-color: var(--card-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .timer {
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stats {
            margin-bottom: 20px;
        }

        .stats h3 {
            margin-bottom: 10px;
            color: var(--secondary-color);
        }

        .stats p {
            margin: 5px 0;
        }

        .hint-section, .settings-section {
            margin-bottom: 20px;
        }

        .hint-section button, .settings-section button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 4px;
            background-color: var(--secondary-color);
            color: white;
            cursor: pointer;
        }

        .hint-section button:hover, .settings-section button:hover {
            background-color: var(--primary-color);
        }

        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: var(--text-color);
        }

        .theme-selector {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        /* Estilos para diferentes tama√±os de Sudoku */
        .sudoku-4x4 {
            grid-template-columns: repeat(4, 1fr);
            max-width: 300px;
        }

        .sudoku-6x6 {
            grid-template-columns: repeat(6, 1fr);
            max-width: 400px;
        }

        .sudoku-9x9 {
            grid-template-columns: repeat(9, 1fr);
            max-width: 500px;
        }

        .sudoku-21x21 {
            grid-template-columns: repeat(21, 1fr);
            max-width: 700px;
        }

        /* Estilos para regiones */
        .region-0 { background-color: rgba(255, 200, 200, 0.3); }
        .region-1 { background-color: rgba(200, 255, 200, 0.3); }
        .region-2 { background-color: rgba(200, 200, 255, 0.3); }
        .region-3 { background-color: rgba(255, 255, 200, 0.3); }
        .region-4 { background-color: rgba(255, 200, 255, 0.3); }
        .region-5 { background-color: rgba(200, 255, 255, 0.3); }

        /* Bordes m√°s gruesos para regiones */
        .border-right-thick {
            border-right: 3px solid var(--text-color) !important;
        }

        .border-bottom-thick {
            border-bottom: 3px solid var(--text-color) !important;
        }

        /* Estilos espec√≠ficos para diferentes tipos de Sudoku */
        .killer-cell {
            background-color: rgba(255, 220, 220, 0.5) !important;
        }

        .killer-sum {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 0.6rem;
            color: #d32f2f;
            font-weight: bold;
        }

        .x-diagonal {
            background: linear-gradient(135deg, rgba(200, 230, 255, 0.4), rgba(150, 200, 255, 0.6)) !important;
        }

        .samurai-center {
            background-color: rgba(255, 240, 200, 0.5) !important;
            border: 2px solid #ff9800 !important;
        }

        .jigsaw-piece {
            background-color: rgba(230, 210, 250, 0.4) !important;
            border-radius: 8px;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--card-color);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close-modal {
            float: right;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            color: var(--secondary-color);
        }

        .close-modal:hover {
            color: var(--primary-color);
        }

        /* Monitor del Algoritmo Gen√©tico */
        #geneticMonitor {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            z-index: 10000;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-menu {
                grid-template-columns: 1fr;
            }
            
            .sudoku-21x21 {
                grid-template-columns: repeat(9, 1fr);
                max-width: 350px;
            }
            
            header h1 {
                font-size: 2rem;
            }
            
            header p {
                font-size: 1rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }

            #geneticMonitor {
                width: 95%;
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .sudoku-9x9 {
                max-width: 350px;
            }
            
            .sudoku-6x6 {
                max-width: 300px;
            }
            
            .sudoku-4x4 {
                max-width: 250px;
            }
            
            .number-selector {
                grid-template-columns: repeat(3, 1fr);
            }

            #geneticMonitor {
                width: 98%;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="theme-selector">
            <select id="themeSelector">
                <option value="light">Tema Claro</option>
                <option value="dark">Tema Oscuro</option>
                <option value="high-contrast">Alto Contraste</option>
            </select>
        </div>

        <!-- P√ÅGINA PRINCIPAL -->
        <div id="mainPage">
            <header>
                <h1>üß© Sudoku Multi-Variante</h1>
                <p>Descubre el fascinante mundo de los Sudokus con m√∫ltiples variantes y desaf√≠os</p>
            </header>

            <div class="main-menu">
                <div class="sudoku-type" data-type="classic">
                    <div class="icon">9√ó9</div>
                    <h3>Sudoku Cl√°sico</h3>
                    <p>El tradicional Sudoku 9√ó9 con reglas est√°ndar. Perfecto para principiantes y expertos.</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>

                <div class="sudoku-type" data-type="killer">
                    <div class="icon">üî¢</div>
                    <h3>Killer Sudoku</h3>
                    <p>Adem√°s de las reglas normales, las celdas sombreadas deben sumar el valor indicado.</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>

                <div class="sudoku-type" data-type="samurai">
                    <div class="icon">üó°Ô∏è</div>
                    <h3>Samurai Sudoku</h3>
                    <p>Cinco sudokus interconectados que se resuelven simult√°neamente. ¬°El desaf√≠o definitivo!</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>

                <div class="sudoku-type" data-type="jigsaw">
                    <div class="icon">üß©</div>
                    <h3>Jigsaw Sudoku</h3>
                    <p>Las regiones tienen formas irregulares en lugar de los tradicionales cuadrados 3√ó3.</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>

                <div class="sudoku-type" data-type="x-sudoku">
                    <div class="icon">‚ùå</div>
                    <h3>X-Sudoku</h3>
                    <p>Las dos diagonales principales tambi√©n deben contener todos los d√≠gitos del 1 al 9.</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>

                <div class="sudoku-type" data-type="mini">
                    <div class="icon">4√ó4</div>
                    <h3>Mini Sudoku</h3>
                    <p>Perfecto para principiantes. Sudokus 4√ó4 y 6√ó6 para aprender las reglas b√°sicas.</p>
                    <button class="play-btn">Jugar Ahora</button>
                </div>
            </div>

            <footer>
                <p>Sudoku Multi-Variante &copy; 2024 - Desarrollado con ‚ù§Ô∏è para amantes del Sudoku</p>
            </footer>
        </div>

        <!-- P√ÅGINA DE JUEGO -->
        <div id="gamePage" class="game-container">
            <div class="nav-buttons">
                <button id="btnBack">‚Üê Volver al Men√∫</button>
                <button id="btnHelp">C√≥mo Jugar</button>
            </div>

            <header>
                <h1 id="gameTitle">Sudoku Cl√°sico</h1>
                <p id="gameDescription">Completa el tablero siguiendo las reglas tradicionales del Sudoku</p>
            </header>

            <div class="difficulty-selector">
                <h3>Selecciona Dificultad:</h3>
                <div class="controls">
                    <button class="difficulty-btn" data-difficulty="easy">F√°cil</button>
                    <button class="difficulty-btn" data-difficulty="medium">Medio</button>
                    <button class="difficulty-btn" data-difficulty="hard">Dif√≠cil</button>
                    <button class="difficulty-btn" data-difficulty="expert">Experto</button>
                </div>
            </div>

            <div class="main-content">
                <div class="game-area">
                    <div class="sudoku-container">
                        <div id="sudokuGrid" class="sudoku-grid sudoku-9x9">
                            <!-- Aqu√≠ se generar√° el tablero din√°micamente -->
                        </div>
                    </div>

                    <div class="controls">
                        <button id="btnCheck">Verificar</button>
                        <button id="btnSolve">Resolver con AG</button>
                        <button id="btnReset">Reiniciar</button>
                        <button id="btnUndo">Deshacer</button>
                        <button id="btnRedo">Rehacer</button>
                        <button id="btnNewGame">Nuevo Juego</button>
                        <button id="btnMonitorGA">Monitor GA</button>
                    </div>

                    <div class="number-selector">
                        <!-- Los botones num√©ricos se generar√°n din√°micamente -->
                    </div>
                </div>

                <div class="sidebar">
                    <div class="timer">
                        <span id="timer">00:00:00</span>
                    </div>

                    <div class="stats">
                        <h3>Estad√≠sticas</h3>
                        <p>Errores: <span id="errorCount">0</span></p>
                        <p>Pistas usadas: <span id="hintCount">0</span></p>
                        <p>Movimientos: <span id="moveCount">0</span></p>
                    </div>

                    <div class="hint-section">
                        <h3>Ayuda</h3>
                        <button id="btnHint">Obtener Pista</button>
                        <button id="btnExplain">Explicar T√©cnica</button>
                        <button id="btnCandidates">Mostrar Candidatos</button>
                    </div>

                    <div class="settings-section">
                        <h3>Opciones</h3>
                        <button id="btnSave">Guardar Partida</button>
                        <button id="btnLoad">Cargar Partida</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- MODAL DE AYUDA -->
        <div id="helpModal" class="modal">
            <div class="modal-content">
                <span class="close-modal">&times;</span>
                <h2 id="modalTitle">C√≥mo Jugar al Sudoku Cl√°sico</h2>
                <div id="modalContent">
                    <!-- El contenido se cargar√° din√°micamente seg√∫n el tipo de sudoku -->
                </div>
            </div>
        </div>

        <!-- MONITOR DEL ALGORITMO GEN√âTICO -->
        <div id="geneticMonitor">
            <h3>üß¨ Algoritmo Gen√©tico en Ejecuci√≥n</h3>
            <div style="text-align: center; margin: 15px 0;">
                <div id="gaProgress" style="height: 20px; background: #f0f0f0; border-radius: 10px; margin: 10px 0;">
                    <div id="gaProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--primary-color), var(--accent-color)); border-radius: 10px; transition: width 0.3s;"></div>
                </div>
                <div id="gaStats" style="font-size: 14px; margin: 10px 0;">
                    <div>Generaci√≥n: <span id="currentGeneration">0</span>/<span id="maxGenerations">5000</span></div>
                    <div>Mejor Fitness: <span id="bestFitness">0</span></div>
                    <div>Tiempo: <span id="gaTime">0</span>s</div>
                </div>
            </div>
            
            <div style="margin: 15px 0;">
                <h4>üìà Evoluci√≥n del Fitness</h4>
                <canvas id="gaChart" width="400" height="200" style="width: 100%; height: 200px; border: 1px solid #ddd;"></canvas>
            </div>
            
            <div style="margin: 15px 0;">
                <h4>üîç √öltima Operaci√≥n</h4>
                <div id="lastOperation" style="font-size: 12px; background: #f8f9fa; padding: 10px; border-radius: 5px;">
                    Preparando algoritmo gen√©tico...
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="stopGeneticAlgorithm()" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    Detener
                </button>
                <button onclick="togglePauseGA()" id="pauseBtn" style="padding: 8px 16px; background: #ffc107; color: black; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">
                    Pausar
                </button>
            </div>
        </div>
    </div>

    <script>
    // ==================== CLASE SudokuGeneticSolver ====================
    class SudokuGeneticSolver {
        constructor(grid, size = 9) {
            this.grid = grid;
            this.size = size;
            this.populationSize = 500;
            this.mutationRate = 0.15;
            this.maxGenerations = 5000;
            this.population = [];
            this.bestSolution = null;
            this.bestFitness = -Infinity;
            this.onGeneration = null;
            this.isPaused = false;
            this.shouldStop = false;
            this.generationCount = 0;
            this.emptyCells = this.findEmptyCells();
        }

        findEmptyCells() {
            const empty = [];
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (this.grid[i][j] === 0) {
                        empty.push({ row: i, col: j });
                    }
                }
            }
            return empty;
        }

        initializePopulation() {
            this.population = [];
            for (let i = 0; i < this.populationSize; i++) {
                const individual = this.createValidIndividual();
                this.population.push(individual);
            }
        }

        createValidIndividual() {
            const individual = JSON.parse(JSON.stringify(this.grid));
            
            for (let startRow = 0; startRow < this.size; startRow += 3) {
                for (let startCol = 0; startCol < this.size; startCol += 3) {
                    this.fillSubgridWithValidNumbers(individual, startRow, startCol);
                }
            }
            
            return individual;
        }

        fillSubgridWithValidNumbers(individual, startRow, startCol) {
            const usedNumbers = new Set();
            const emptyPositions = [];
            
            for (let i = startRow; i < startRow + 3; i++) {
                for (let j = startCol; j < startCol + 3; j++) {
                    if (individual[i][j] !== 0) {
                        usedNumbers.add(individual[i][j]);
                    } else {
                        emptyPositions.push({ row: i, col: j });
                    }
                }
            }
            
            const missingNumbers = [];
            for (let num = 1; num <= 9; num++) {
                if (!usedNumbers.has(num)) {
                    missingNumbers.push(num);
                }
            }
            
            this.shuffleArray(missingNumbers);
            for (let idx = 0; idx < emptyPositions.length; idx++) {
                const pos = emptyPositions[idx];
                individual[pos.row][pos.col] = missingNumbers[idx];
            }
        }

        calculateFitness(individual) {
            let fitness = 1000;
            
            for (let i = 0; i < this.size; i++) {
                const rowSet = new Set();
                for (let j = 0; j < this.size; j++) {
                    rowSet.add(individual[i][j]);
                }
                fitness -= (this.size - rowSet.size) * 10;
            }
            
            for (let j = 0; j < this.size; j++) {
                const colSet = new Set();
                for (let i = 0; i < this.size; i++) {
                    colSet.add(individual[i][j]);
                }
                fitness -= (this.size - colSet.size) * 10;
            }
            
            fitness += 50;
            return fitness;
        }

        rouletteSelection() {
            const totalFitness = this.population.reduce((sum, ind) => sum + this.calculateFitness(ind), 0);
            let random = Math.random() * totalFitness;
            
            for (const individual of this.population) {
                random -= this.calculateFitness(individual);
                if (random <= 0) {
                    return individual;
                }
            }
            
            return this.population[this.population.length - 1];
        }

        crossover(parent1, parent2) {
            const child = JSON.parse(JSON.stringify(this.grid));
            const crossoverPoint = Math.floor(Math.random() * this.emptyCells.length);
            
            for (let i = 0; i < this.emptyCells.length; i++) {
                const cell = this.emptyCells[i];
                if (i < crossoverPoint) {
                    child[cell.row][cell.col] = parent1[cell.row][cell.col];
                } else {
                    child[cell.row][cell.col] = parent2[cell.row][cell.col];
                }
            }
            
            return child;
        }

        mutate(individual) {
            if (Math.random() < this.mutationRate) {
                const subgridRow = Math.floor(Math.random() * 3) * 3;
                const subgridCol = Math.floor(Math.random() * 3) * 3;
                
                const mutableCells = [];
                for (let i = subgridRow; i < subgridRow + 3; i++) {
                    for (let j = subgridCol; j < subgridCol + 3; j++) {
                        if (this.grid[i][j] === 0) {
                            mutableCells.push({ row: i, col: j });
                        }
                    }
                }
                
                if (mutableCells.length >= 2) {
                    const [cell1, cell2] = this.selectRandomCells(mutableCells, 2);
                    [individual[cell1.row][cell1.col], individual[cell2.row][cell2.col]] = 
                    [individual[cell2.row][cell2.col], individual[cell1.row][cell1.col]];
                }
            }
            
            return individual;
        }

        evolve() {
            const newPopulation = [];
            
            if (this.bestSolution) {
                newPopulation.push(JSON.parse(JSON.stringify(this.bestSolution)));
            }
            
            while (newPopulation.length < this.populationSize) {
                const parent1 = this.rouletteSelection();
                const parent2 = this.rouletteSelection();
                let child = this.crossover(parent1, parent2);
                child = this.mutate(child);
                newPopulation.push(child);
            }
            
            this.population = newPopulation;
        }

        async solve() {
            console.log("üß¨ Iniciando algoritmo gen√©tico...");
            this.shouldStop = false;
            this.generationCount = 0;
            
            this.initializePopulation();
            
            for (let generation = 0; generation < this.maxGenerations; generation++) {
                this.generationCount = generation;
                
                while (this.isPaused && !this.shouldStop) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                if (this.shouldStop) break;
                
                let bestGenFitness = -Infinity;
                let bestGenSolution = null;
                let foundPerfectSolution = false;
                
                for (const individual of this.population) {
                    const fitness = this.calculateFitness(individual);
                    
                    if (fitness > bestGenFitness) {
                        bestGenFitness = fitness;
                        bestGenSolution = JSON.parse(JSON.stringify(individual));
                    }
                    
                    if (this.isPerfectSolution(individual)) {
                        console.log(`‚úÖ Soluci√≥n perfecta encontrada en generaci√≥n ${generation}`);
                        foundPerfectSolution = true;
                        bestGenSolution = individual;
                        bestGenFitness = 1000;
                        break;
                    }
                }
                
                if (bestGenFitness > this.bestFitness) {
                    this.bestFitness = bestGenFitness;
                    this.bestSolution = bestGenSolution;
                }
                
                if (this.onGeneration) {
                    this.onGeneration({
                        generation,
                        bestFitness: this.bestFitness,
                        currentFitness: bestGenFitness,
                        bestSolution: this.bestSolution,
                        operation: foundPerfectSolution ? 
                            "¬°Soluci√≥n perfecta encontrada!" : 
                            `Generaci√≥n ${generation} completada`
                    });
                }
                
                if (generation % 50 === 0) {
                    console.log(`Gen ${generation}: Mejor fitness = ${this.bestFitness}`);
                }
                
                if (foundPerfectSolution) {
                    return bestGenSolution;
                }
                
                this.evolve();
            }
            
            console.log("‚è∞ L√≠mite de generaciones alcanzado");
            return this.bestSolution;
        }

        isPerfectSolution(individual) {
            for (let i = 0; i < this.size; i++) {
                const rowSet = new Set(individual[i]);
                if (rowSet.size !== this.size) return false;
            }
            
            for (let j = 0; j < this.size; j++) {
                const colSet = new Set();
                for (let i = 0; i < this.size; i++) {
                    colSet.add(individual[i][j]);
                }
                if (colSet.size !== this.size) return false;
            }
            
            return true;
        }

        pause() { this.isPaused = true; }
        resume() { this.isPaused = false; }
        stop() { this.shouldStop = true; this.isPaused = false; }

        shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        selectRandomCells(cells, count) {
            const shuffled = [...cells];
            this.shuffleArray(shuffled);
            return shuffled.slice(0, count);
        }
    }

    // ==================== CLASE SudokuEngine ====================
    class SudokuEngine {
        constructor() {
            this.grid = null;
            this.solver = null;
            this.fitnessHistory = [];
            this.gaStartTime = null;
            this.gaInterval = null;
        }

        gridToMatrix(sudokuGrid) {
            const matrix = [];
            const cells = sudokuGrid.querySelectorAll('.sudoku-cell');
            const size = Math.sqrt(cells.length);

            for (let i = 0; i < size; i++) {
                matrix[i] = [];
                for (let j = 0; j < size; j++) {
                    const cell = cells[i * size + j];
                    const value = cell.textContent.trim();
                    matrix[i][j] = value === '' ? 0 : parseInt(value);
                }
            }

            return matrix;
        }

        matrixToGrid(matrix, sudokuGrid) {
            const cells = sudokuGrid.querySelectorAll('.sudoku-cell');
            const size = matrix.length;

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const cell = cells[i * size + j];
                    if (!cell.classList.contains('fixed')) {
                        cell.textContent = matrix[i][j] === 0 ? '' : matrix[i][j];
                        cell.classList.remove('error');
                    }
                }
            }
        }

        async solveWithGeneticAlgorithm(sudokuGrid) {
            try {
                this.showGeneticMonitor();
                this.fitnessHistory = [];
                
                const matrix = this.gridToMatrix(sudokuGrid);
                
                if (!this.isValidPuzzle(matrix)) {
                    alert('‚ùå El sudoku no es v√°lido o no tiene soluci√≥n');
                    this.hideGeneticMonitor();
                    return false;
                }
                
                this.solver = new SudokuGeneticSolver(matrix);
                
                this.solver.onGeneration = (data) => {
                    this.updateGeneticMonitor(data);
                };

                const solution = await this.solver.solve();
                
                if (solution && this.isPerfectSolution(solution)) {
                    this.matrixToGrid(solution, sudokuGrid);
                    this.hideGeneticMonitor();
                    return true;
                } else {
                    this.hideGeneticMonitor();
                    alert('‚ö†Ô∏è No se encontr√≥ soluci√≥n perfecta. Mostrando mejor intento...');
                    if (solution) {
                        this.matrixToGrid(solution, sudokuGrid);
                    }
                    return false;
                }
                
            } catch (error) {
                console.error('Error en algoritmo gen√©tico:', error);
                this.hideGeneticMonitor();
                alert('‚ùå Error en el algoritmo gen√©tico: ' + error.message);
                return false;
            }
        }

        isValidPuzzle(matrix) {
            const size = matrix.length;
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const num = matrix[i][j];
                    if (num < 0 || num > 9) return false;
                }
            }
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const num = matrix[i][j];
                    if (num !== 0) {
                        for (let k = 0; k < size; k++) {
                            if (k !== j && matrix[i][k] === num) return false;
                        }
                        for (let k = 0; k < size; k++) {
                            if (k !== i && matrix[k][j] === num) return false;
                        }
                        const startRow = Math.floor(i / 3) * 3;
                        const startCol = Math.floor(j / 3) * 3;
                        for (let x = startRow; x < startRow + 3; x++) {
                            for (let y = startCol; y < startCol + 3; y++) {
                                if (x !== i && y !== j && matrix[x][y] === num) return false;
                            }
                        }
                    }
                }
            }
            
            return true;
        }

        isPerfectSolution(matrix) {
            const size = matrix.length;
            
            for (let i = 0; i < size; i++) {
                const rowSet = new Set();
                const colSet = new Set();
                
                for (let j = 0; j < size; j++) {
                    if (matrix[i][j] === 0 || rowSet.has(matrix[i][j])) return false;
                    rowSet.add(matrix[i][j]);
                    
                    if (matrix[j][i] === 0 || colSet.has(matrix[j][i])) return false;
                    colSet.add(matrix[j][i]);
                }
            }
            
            for (let i = 0; i < size; i += 3) {
                for (let j = 0; j < size; j += 3) {
                    const subgridSet = new Set();
                    for (let x = i; x < i + 3; x++) {
                        for (let y = j; y < j + 3; y++) {
                            if (matrix[x][y] === 0 || subgridSet.has(matrix[x][y])) return false;
                            subgridSet.add(matrix[x][y]);
                        }
                    }
                }
            }
            
            return true;
        }

        isSolvedCorrectly(sudokuGrid) {
            const matrix = this.gridToMatrix(sudokuGrid);
            const size = matrix.length;

            for (let i = 0; i < size; i++) {
                const rowSet = new Set(matrix[i]);
                if (rowSet.size !== size || rowSet.has(0)) return false;
            }

            for (let j = 0; j < size; j++) {
                const colSet = new Set();
                for (let i = 0; i < size; i++) {
                    colSet.add(matrix[i][j]);
                }
                if (colSet.size !== size) return false;
            }

            for (let i = 0; i < size; i += 3) {
                for (let j = 0; j < size; j += 3) {
                    const subgridSet = new Set();
                    for (let x = i; x < i + 3; x++) {
                        for (let y = j; y < j + 3; y++) {
                            subgridSet.add(matrix[x][y]);
                        }
                    }
                    if (subgridSet.size !== size) return false;
                }
            }

            return true;
        }

        showGeneticMonitor() {
            const monitor = document.getElementById('geneticMonitor');
            if (monitor) {
                monitor.style.display = 'block';
                this.gaStartTime = Date.now();
                this.startGATimer();
            }
        }

        hideGeneticMonitor() {
            const monitor = document.getElementById('geneticMonitor');
            if (monitor) {
                monitor.style.display = 'none';
                this.stopGATimer();
            }
        }

        startGATimer() {
            this.stopGATimer();
            this.gaInterval = setInterval(() => {
                this.updateGATime();
            }, 1000);
        }

        stopGATimer() {
            if (this.gaInterval) {
                clearInterval(this.gaInterval);
                this.gaInterval = null;
            }
        }

        updateGATime() {
            if (this.gaStartTime) {
                const elapsed = Math.floor((Date.now() - this.gaStartTime) / 1000);
                const timeElement = document.getElementById('gaTime');
                if (timeElement) timeElement.textContent = elapsed;
            }
        }

        updateGeneticMonitor(data) {
            const genElement = document.getElementById('currentGeneration');
            const fitnessElement = document.getElementById('bestFitness');
            const maxGenElement = document.getElementById('maxGenerations');
            const opElement = document.getElementById('lastOperation');
            
            if (genElement) genElement.textContent = data.generation;
            if (fitnessElement) fitnessElement.textContent = data.bestFitness;
            if (maxGenElement) maxGenElement.textContent = this.solver.maxGenerations;
            if (opElement) opElement.textContent = data.operation;

            const progressBar = document.getElementById('gaProgressBar');
            if (progressBar) {
                const progress = (data.generation / this.solver.maxGenerations) * 100;
                progressBar.style.width = Math.min(progress, 100) + '%';
            }

            this.fitnessHistory.push(data.bestFitness);
            this.updateFitnessChart();
            this.updateGATime();
        }

        updateFitnessChart() {
            const canvas = document.getElementById('gaChart');
            if (!canvas || this.fitnessHistory.length < 2) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const maxFitness = Math.max(...this.fitnessHistory);
            const minFitness = Math.min(...this.fitnessHistory);
            const range = Math.max(maxFitness - minFitness, 1);

            ctx.beginPath();
            ctx.strokeStyle = '#4a6fa5';
            ctx.lineWidth = 2;
            
            this.fitnessHistory.forEach((fitness, index) => {
                const x = (index / (this.fitnessHistory.length - 1)) * canvas.width;
                const y = canvas.height - ((fitness - minFitness) / range) * canvas.height;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();

            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();

            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.fillText('Generaciones', canvas.width / 2 - 30, canvas.height - 5);
            ctx.save();
            ctx.translate(10, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Fitness', 0, 0);
            ctx.restore();
        }

        pauseGeneticAlgorithm() {
            if (this.solver) {
                this.solver.pause();
                const btn = document.getElementById('pauseBtn');
                if (btn) {
                    btn.textContent = 'Reanudar';
                    btn.style.background = '#28a745';
                }
            }
        }

        resumeGeneticAlgorithm() {
            if (this.solver) {
                this.solver.resume();
                const btn = document.getElementById('pauseBtn');
                if (btn) {
                    btn.textContent = 'Pausar';
                    btn.style.background = '#ffc107';
                }
            }
        }

        stopGeneticAlgorithm() {
            if (this.solver) {
                this.solver.stop();
                this.hideGeneticMonitor();
            }
        }
    }

    // ==================== C√ìDIGO PRINCIPAL ====================
    document.addEventListener('DOMContentLoaded', function() {
        let currentGameType = 'classic';
        let currentDifficulty = 'medium';
        let selectedCell = null;
        let gameHistory = [];
        let historyPointer = -1;
        let timerInterval = null;
        let startTime = null;
        let errorCount = 0;
        let hintCount = 0;
        let moveCount = 0;
        let showingCandidates = false;

        const sudokuEngine = new SudokuEngine();
<!-- Solo el c√≥digo JavaScript necesario para restaurar el sistema de ayuda -->

// ==================== SISTEMA DE AYUDA CONTEXTUAL ====================
const helpContent = {
    'classic': `
        <h3>Reglas del Sudoku Cl√°sico</h3>
        <p>El objetivo es rellenar una cuadr√≠cula de 9√ó9 con d√≠gitos del 1 al 9 de modo que:</p>
        <ul>
            <li>Cada fila contenga todos los n√∫meros del 1 al 9 sin repetir</li>
            <li>Cada columna contenga todos los n√∫meros del 1 al 9 sin repetir</li>
            <li>Cada subcuadr√≠cula 3√ó3 contenga todos los n√∫meros del 1 al 9 sin repetir</li>
        </ul>
    `,
    
    'killer': `
        <h3>Reglas del Killer Sudoku</h3>
        <p>Adem√°s de las reglas del Sudoku cl√°sico:</p>
        <ul>
            <li>Las celdas sombreadas forman "jaulas" con un n√∫mero indicado (suma total)</li>
            <li>Los n√∫meros dentro de cada jaula deben sumar exactamente el valor mostrado</li>
            <li>Los n√∫meros dentro de una jaula no pueden repetirse</li>
        </ul>
    `,
    
    'samurai': `
        <h3>Reglas del Samurai Sudoku</h3>
        <p>Consiste en 5 sudokus interconectados:</p>
        <ul>
            <li>4 sudokus en las esquinas y 1 en el centro que se superpone con los otros</li>
            <li>Cada sudoku individual debe seguir las reglas cl√°sicas</li>
            <li>Las √°reas superpuestas deben satisfacer las reglas de ambos sudokus</li>
        </ul>
    `,
    
    'jigsaw': `
        <h3>Reglas del Jigsaw Sudoku</h3>
        <p>Variante con regiones de forma irregular:</p>
        <ul>
            <li>Las regiones no son cuadrados 3√ó3 tradicionales</li>
            <li>Cada regi√≥n debe contener todos los n√∫meros del 1 al 9 sin repetir</li>
            <li>Se mantienen las reglas de filas y columnas del Sudoku cl√°sico</li>
        </ul>
    `,
    
    'x-sudoku': `
        <h3>Reglas del X-Sudoku</h3>
        <p>Sudoku cl√°sico con regla adicional:</p>
        <ul>
            <li>Las dos diagonales principales deben contener todos los n√∫meros del 1 al 9</li>
            <li>Se mantienen todas las reglas del Sudoku cl√°sico</li>
            <li>Las diagonales son restricciones adicionales, no reemplazan otras reglas</li>
        </ul>
    `,
    
    'mini': `
        <h3>Reglas del Mini Sudoku</h3>
        <p>Versiones m√°s peque√±as para principiantes:</p>
        <ul>
            <li><strong>4√ó4:</strong> N√∫meros del 1 al 4, regiones 2√ó2</li>
            <li><strong>6√ó6:</strong> N√∫meros del 1 al 6, regiones 2√ó3 o 3√ó2</li>
            <li>Mismas reglas que el Sudoku cl√°sico pero con menos casillas</li>
        </ul>
    `
};

function showHelpModal() {
    const modalTitle = document.getElementById('modalTitle');
    const modalContent = document.getElementById('modalContent');
    
    const titles = {
        'classic': 'Sudoku Cl√°sico',
        'killer': 'Killer Sudoku', 
        'samurai': 'Samurai Sudoku',
        'jigsaw': 'Jigsaw Sudoku',
        'x-sudoku': 'X-Sudoku',
        'mini': 'Mini Sudoku'
    };
    
    modalTitle.textContent = `C√≥mo Jugar al ${titles[currentGameType]}`;
    modalContent.innerHTML = helpContent[currentGameType];
    document.getElementById('helpModal').style.display = 'flex';
}

// Agregar este event listener en la funci√≥n setupEventListeners()
document.getElementById('btnHelp').addEventListener('click', showHelpModal);

        function initializeGame() {
            showMainPage();
        }

        function showMainPage() {
            document.getElementById('mainPage').style.display = 'block';
            document.getElementById('gamePage').style.display = 'none';
        }

        function showGamePage() {
            document.getElementById('mainPage').style.display = 'none';
            document.getElementById('gamePage').style.display = 'block';
            initializeGameBoard();
        }

        function initializeGameBoard() {
            generateNumberSelector();
            createGridForGameType(currentGameType);
            updateStats();
            updateButtonStates();
            resetTimer();
        }

        function generateNumberSelector() {
            const selector = document.querySelector('.number-selector');
            selector.innerHTML = '';
            
            let maxNumber = 9;
            if (currentGameType === 'mini') {
                maxNumber = currentDifficulty === 'easy' ? 4 : 6;
            }
            
            for (let i = 1; i <= maxNumber; i++) {
                const btn = document.createElement('button');
                btn.className = 'number-btn';
                btn.textContent = i;
                btn.dataset.value = i;
                btn.addEventListener('click', () => {
                    if (selectedCell) {
                        setCellValue(selectedCell, i);
                    }
                });
                selector.appendChild(btn);
            }
            
            const clearBtn = document.createElement('button');
            clearBtn.className = 'number-btn';
            clearBtn.textContent = 'X';
            clearBtn.addEventListener('click', () => {
                if (selectedCell && !selectedCell.classList.contains('fixed')) {
                    setCellValue(selectedCell, '');
                }
            });
            selector.appendChild(clearBtn);
        }

        function createGridForGameType(gameType) {
            let size = 9;
            let gridClass = 'sudoku-9x9';
            
            switch(gameType) {
                case 'classic':
                case 'killer':
                case 'jigsaw':
                case 'x-sudoku':
                    size = 9;
                    gridClass = 'sudoku-9x9';
                    break;
                case 'samurai':
                    size = 21;
                    gridClass = 'sudoku-21x21';
                    break;
                case 'mini':
                    size = currentDifficulty === 'easy' ? 4 : 6;
                    gridClass = currentDifficulty === 'easy' ? 'sudoku-4x4' : 'sudoku-6x6';
                    break;
            }
            
            createEmptyGrid(size, gridClass);
        }

        function createEmptyGrid(size, gridClass) {
            const grid = document.getElementById('sudokuGrid');
            grid.innerHTML = '';
            grid.className = `sudoku-grid ${gridClass}`;
            
            const regionSize = Math.sqrt(size);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'sudoku-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    const regionRow = Math.floor(i / regionSize);
                    const regionCol = Math.floor(j / regionSize);
                    const region = regionRow * regionSize + regionCol;
                    cell.classList.add(`region-${region % 6}`);
                    
                    if ((j + 1) % regionSize === 0 && j !== size - 1) {
                        cell.classList.add('border-right-thick');
                    }
                    if ((i + 1) % regionSize === 0 && i !== size - 1) {
                        cell.classList.add('border-bottom-thick');
                    }
                    
                    cell.addEventListener('click', () => selectCell(cell));
                    grid.appendChild(cell);
                }
            }
        }

        function selectCell(cell) {
            if (selectedCell) {
                selectedCell.classList.remove('selected');
            }
            
            selectedCell = cell;
            cell.classList.add('selected');
        }

        function setCellValue(cell, value) {
            if (cell.classList.contains('fixed')) {
                return;
            }
            
            saveToHistory();
            cell.textContent = value;
            moveCount++;
            updateStats();
            updateButtonStates();
        }

        function saveToHistory() {
            if (historyPointer < gameHistory.length - 1) {
                gameHistory = gameHistory.slice(0, historyPointer + 1);
            }
            
            const gridState = [];
            document.querySelectorAll('.sudoku-cell').forEach(cell => {
                gridState.push({
                    row: cell.dataset.row,
                    col: cell.dataset.col,
                    value: cell.textContent,
                    isFixed: cell.classList.contains('fixed')
                });
            });
            
            gameHistory.push(gridState);
            historyPointer = gameHistory.length - 1;
        }

        function undo() {
            if (historyPointer > 0) {
                historyPointer--;
                restoreFromHistory();
                updateButtonStates();
            }
        }

        function redo() {
            if (historyPointer < gameHistory.length - 1) {
                historyPointer++;
                restoreFromHistory();
                updateButtonStates();
            }
        }

        function restoreFromHistory() {
            const gridState = gameHistory[historyPointer];
            
            gridState.forEach(cellState => {
                const cell = document.querySelector(`.sudoku-cell[data-row="${cellState.row}"][data-col="${cellState.col}"]`);
                if (cell) {
                    cell.textContent = cellState.value;
                    
                    if (cellState.isFixed) {
                        cell.classList.add('fixed');
                    } else {
                        cell.classList.remove('fixed');
                    }
                    
                    cell.classList.remove('error');
                }
            });
        }

        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            startTime = new Date();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function resetTimer() {
            stopTimer();
            document.getElementById('timer').textContent = '00:00:00';
        }

        function updateTimer() {
            const now = new Date();
            const elapsed = new Date(now - startTime);
            
            const hours = elapsed.getUTCHours().toString().padStart(2, '0');
            const minutes = elapsed.getUTCMinutes().toString().padStart(2, '0');
            const seconds = elapsed.getUTCSeconds().toString().padStart(2, '0');
            
            document.getElementById('timer').textContent = `${hours}:${minutes}:${seconds}`;
        }

        function updateStats() {
            document.getElementById('errorCount').textContent = errorCount;
            document.getElementById('hintCount').textContent = hintCount;
            document.getElementById('moveCount').textContent = moveCount;
        }

        function updateButtonStates() {
            document.getElementById('btnUndo').disabled = historyPointer <= 0;
            document.getElementById('btnRedo').disabled = historyPointer >= gameHistory.length - 1;
        }

        function loadSettings() {
            const theme = localStorage.getItem('theme') || 'light';
            document.getElementById('themeSelector').value = theme;
            applyTheme(theme);
        }

        function applyTheme(theme) {
            document.body.className = '';
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
            } else if (theme === 'high-contrast') {
                document.body.classList.add('high-contrast-theme');
            }
        }

        // ==================== EVENT LISTENERS ====================
        function setupEventListeners() {
            document.querySelectorAll('.play-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const sudokuType = this.closest('.sudoku-type').dataset.type;
                    currentGameType = sudokuType;
                    updateGameTitle();
                    showGamePage();
                    startNewGame(currentDifficulty);
                });
            });

            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    currentDifficulty = this.dataset.difficulty;
                    startNewGame(currentDifficulty);
                });
            });

            document.getElementById('btnBack').addEventListener('click', showMainPage);
            document.getElementById('btnCheck').addEventListener('click', checkSolution);
            document.getElementById('btnSolve').addEventListener('click', solvePuzzle);
            document.getElementById('btnReset').addEventListener('click', resetPuzzle);
            document.getElementById('btnUndo').addEventListener('click', undo);
            document.getElementById('btnRedo').addEventListener('click', redo);
            document.getElementById('btnNewGame').addEventListener('click', () => startNewGame(currentDifficulty));
            document.getElementById('btnHint').addEventListener('click', getHint);
            document.getElementById('btnExplain').addEventListener('click', explainTechnique);
            document.getElementById('btnCandidates').addEventListener('click', showCandidates);
            document.getElementById('btnSave').addEventListener('click', saveGame);
            document.getElementById('btnLoad').addEventListener('click', loadGame);
            document.getElementById('btnMonitorGA').addEventListener('click', () => sudokuEngine.showGeneticMonitor());

            document.getElementById('themeSelector').addEventListener('change', function() {
                applyTheme(this.value);
                localStorage.setItem('theme', this.value);
            });

            document.querySelector('.close-modal').addEventListener('click', function() {
                document.getElementById('helpModal').style.display = 'none';
            });

            document.getElementById('btnHelp').addEventListener('click', function() {
                document.getElementById('helpModal').style.display = 'flex';
            });

            window.addEventListener('click', function(event) {
                if (event.target === document.getElementById('helpModal')) {
                    document.getElementById('helpModal').style.display = 'none';
                }
            });
        }

        function updateGameTitle() {
            const titles = {
                'classic': 'Sudoku Cl√°sico',
                'killer': 'Killer Sudoku',
                'samurai': 'Samurai Sudoku',
                'jigsaw': 'Jigsaw Sudoku',
                'x-sudoku': 'X-Sudoku',
                'mini': 'Mini Sudoku'
            };
            
            document.getElementById('gameTitle').textContent = titles[currentGameType];
            document.getElementById('gameDescription').textContent = 'Completa el tablero siguiendo las reglas del juego';
        }

        function startNewGame(difficulty) {
            saveToHistory();
            resetStats();
            resetTimer();
            startTimer();
            simulateGameGeneration(difficulty);
            updateButtonStates();
        }

        function simulateGameGeneration(difficulty) {
            const cells = document.querySelectorAll('.sudoku-cell');
            const fixedCellsCount = {
                'easy': 0.4,
                'medium': 0.3,
                'hard': 0.25,
                'expert': 0.2
            }[difficulty];
            
            cells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('fixed', 'error');
            });
            
            const totalCells = cells.length;
            const fixedCount = Math.floor(totalCells * fixedCellsCount);
            
            for (let i = 0; i < fixedCount; i++) {
                const randomIndex = Math.floor(Math.random() * totalCells);
                const randomCell = cells[randomIndex];
                
                if (!randomCell.classList.contains('fixed')) {
                    const maxNumber = currentGameType === 'mini' ? (currentDifficulty === 'easy' ? 4 : 6) : 9;
                    const randomValue = Math.floor(Math.random() * maxNumber) + 1;
                    randomCell.textContent = randomValue;
                    randomCell.classList.add('fixed');
                }
            }
        }

        async function solvePuzzle() {
            const sudokuGrid = document.getElementById('sudokuGrid');
            const btnSolve = document.getElementById('btnSolve');
            
            try {
                btnSolve.disabled = true;
                btnSolve.textContent = 'Resolviendo...';
                
                const success = await sudokuEngine.solveWithGeneticAlgorithm(sudokuGrid);
                
                if (success) {
                    if (sudokuEngine.isSolvedCorrectly(sudokuGrid)) {
                        alert('‚úÖ ¬°Sudoku resuelto correctamente con algoritmo gen√©tico!');
                        stopTimer();
                    } else {
                        alert('‚ö†Ô∏è Soluci√≥n encontrada pero puede contener errores. Verifica manualmente.');
                    }
                } else {
                    alert('‚ùå No se pudo encontrar una soluci√≥n perfecta. Intenta con un sudoku m√°s f√°cil.');
                }
            } catch (error) {
                console.error('Error:', error);
                alert('‚ùå Error al resolver el sudoku: ' + error.message);
            } finally {
                btnSolve.disabled = false;
                btnSolve.textContent = 'Resolver con AG';
            }
        }

        function checkSolution() {
            const sudokuGrid = document.getElementById('sudokuGrid');
            if (sudokuEngine.isSolvedCorrectly(sudokuGrid)) {
                alert('‚úÖ ¬°Felicidades! La soluci√≥n es correcta.');
                stopTimer();
            } else {
                alert('‚ùå La soluci√≥n contiene errores. Sigue intent√°ndolo.');
            }
        }

        function resetPuzzle() {
            if (confirm('¬øReiniciar el puzzle?')) {
                if (gameHistory.length > 0) {
                    historyPointer = 0;
                    restoreFromHistory();
                    resetStats();
                    resetTimer();
                    updateButtonStates();
                }
            }
        }

        function getHint() {
            hintCount++;
            updateStats();
            alert('Pista: Intenta buscar n√∫meros √∫nicos en cada fila y columna.');
        }

        function explainTechnique() {
            alert('T√©cnica: Busca celdas donde solo un n√∫mero puede encajar basedo en las restricciones.');
        }

        function showCandidates() {
            showingCandidates = !showingCandidates;
            alert(showingCandidates ? 'Mostrando candidatos' : 'Ocultando candidatos');
        }

        function saveGame() {
            alert('Partida guardada correctamente.');
        }

        function loadGame() {
            alert('Partida cargada correctamente.');
        }

        function resetStats() {
            errorCount = 0;
            hintCount = 0;
            moveCount = 0;
            updateStats();
        }

        // Funciones globales para los botones del monitor
        window.togglePauseGA = function() {
            if (sudokuEngine.solver && sudokuEngine.solver.isPaused) {
                sudokuEngine.resumeGeneticAlgorithm();
            } else {
                sudokuEngine.pauseGeneticAlgorithm();
            }
        };

        window.stopGeneticAlgorithm = function() {
            sudokuEngine.stopGeneticAlgorithm();
            alert('Algoritmo gen√©tico detenido');
        };

        // Inicializar la aplicaci√≥n
        initializeGame();
        setupEventListeners();
        loadSettings();
    });
    </script>
</body>
</html>